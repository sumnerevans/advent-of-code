/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package d05

import java.io.BufferedReader
import java.io.File
import java.math.BigInteger

fun main() {
    val filename =
            "/home/sumner/projects/github.com/sumnerevans/advent-of-code/y2023/d05/05.test.1.txt"
    // "/home/sumner/projects/github.com/sumnerevans/advent-of-code/y2023/d05/05.txt"
    val bufferedReader: BufferedReader = File(filename).bufferedReader()

    val seeds =
            bufferedReader
                    .readLine()
                    .substring(7)
                    .split(" ")
                    .map { it.toBigInteger() }
                    .toMutableList()
    var seedRanges =
            seeds.chunked(2)
                    .map { listOf(it[0], it[0] + it[1]) to 0.toBigInteger() }
                    .toMutableList()
    seedRanges.sortBy { it.first[0] }
    println(seeds)
    println(seedRanges)

    bufferedReader.readLine() // eat the first empty line

    while (true) {
        if (bufferedReader.readLine() == null) { // eat the map line
            break
        }

        val transforms = mutableListOf<Array<BigInteger>>()
        while (true) {
            val line = bufferedReader.readLine()
            if (line == null || line == "") {
                break
            }
            val (dst, src, len) = line.split(" ")
            transforms.add(arrayOf(dst.toBigInteger(), src.toBigInteger(), len.toBigInteger()))
        }
        for (i in 0 until seeds.size) {
            for ((dst, src, len) in transforms) {
                if (seeds[i] >= src && seeds[i] <= src + len) {
                    seeds[i] = dst + seeds[i] - src
                    break
                }
            }
        }
        val newSeedRanges = mutableListOf<Pair<List<BigInteger>, BigInteger>>()
        for (seedRange in seedRanges) {
            val (range, offset) = seedRange
            val (start, end) = range
            var transformed = false
            for ((dst, src, len) in transforms) {
                val transform_start = src
                val transform_end = src + len
                val transform_offset = dst - src

                // the seed range entirely contains the transform range
                if (start <= transform_start && end >= transform_end) {
                    newSeedRanges.add(listOf(start, transform_start - 1.toBigInteger()) to offset)
                    newSeedRanges.add(
                            listOf(transform_start, transform_end) to offset + transform_offset
                    )
                    newSeedRanges.add(
                            listOf(transform_end + 1.toBigInteger(), end) to
                                    offset + transform_offset
                    )
                    transformed = true
                }
                // the seed range is entirely contained by the transform range
                else if (start >= transform_start && end <= transform_end) {
                    newSeedRanges.add(listOf(start, end) to offset + transform_offset)
                    transformed = true
                }
                // the seed range starts before the transform range and ends inside it
                else if (start <= transform_start && end >= transform_start && end <= transform_end
                ) {
                    newSeedRanges.add(listOf(start, transform_start - 1.toBigInteger()) to offset)
                    newSeedRanges.add(listOf(transform_start, end) to offset + transform_offset)
                    transformed = true
                }
                // the seed range starts inside the transform range and ends after it
                else if (start >= transform_start && start <= transform_end && end >= transform_end
                ) {
                    newSeedRanges.add(listOf(start, transform_end) to offset + transform_offset)
                    newSeedRanges.add(
                            listOf(transform_end + 1.toBigInteger(), end) to
                                    offset + transform_offset
                    )
                    transformed = true
                }
            }
            if (!transformed) newSeedRanges.add(listOf(start, end) to offset)
        }
        seedRanges.sortBy { it.first[0] }
        println(newSeedRanges)
        seedRanges = newSeedRanges
    }
    print("Part 1: ")
    println(seeds.min())

    print("Part 2: ")
        println(seedRanges)
    println(seedRanges.minBy { it.first[0] - it.second })
}
